                       ____                   _____                    _
                      / ___|_ __ ___  _ __   |  ___|_ _ _ __ _ __ ___ (_)_ __   __ _
                     | |   | '__/ _ \| '_ \  | |_ / _` | '__| '_ ` _ \| | '_ \ / _` |
                     | |___| | | (_) | |_) | |  _| (_| | |  | | | | | | | | | | (_| |
                      \____|_|  \___/| .__/  |_|  \__,_|_|  |_| |_| |_|_|_| |_|\__, |
                                     |_|                                       |___/
 
In Crop Farming you take care of a plant (Tulip/Eucalyptus) and try to get the plant to a health level of 50. To do that the stats of your plant, water, soil sunlight and much more have to be at a certain level which differ from the type of plant you have; if your plant meets the requirements then your plant's health goes up by 2 if it is a Tulip and by 1 if it is an Eucalyptus plant. Therefore the Tulip is easy difficulty and the Eucalyptus medium difficulty. Once your plant gets to a healthy level of 50 YOU WIN THE GAME!!. On the contrary if you are not able to keep your plant on the required level health goes down by 1, and if health reaches 0 that is the end of the game.
 
 
Changes from last report
    Originally the game was made to be run through the command line and just add text as the game progressed. As I continued with the idea that text was just going to be piled on the terminal the more clustered and less intuitive the game became. I tried just adding a bunch of spaces and a "press enter to continue" feature but the game was still choppy and the fast refresh was making the game harder to follow with. This is when I decided to implement ncurses to make my game graphics and the way the user interacts with the plant a smoother and overall a better experience. With ncurses the console can have colors, the terminal can be refreshed whenever a new graphic or text is inputted or outputted into the terminal, letting me have greater control over how the game looks. Implementing ncurses was more challenging than I thought since I had to re-write most of my code. Every cout had to be replaced and the logic was a bit different than what I had thought of with just a pile on game. User input even though it was harder to implement with ncurses it was more responsive and it handled more use cases. The biggest pro gained with user input and ncurses is the outlying and error cases. With just the command line it was hard to implement a loop that kept going until a valid answer was given but with ncurses since user input is handled by a switch the default case would take care of that. Another problem that was encountered in the implementation of user input with ncurse was the enter key. The enter key was not reliable and sometimes it would work and sometimes not, that was changed by the 'e' key and after that there were no problems with going on to the next screen. Besides the user input there were not any more critical/major changes that were made from the original design.
 
User Input
    All of the user input menus follow the same structure/design. The menu is drawn with a function and then the input is taken with a while loop. The while loop acts either as a stop to not continue until a key is pressed or to keep showing a text (which would be inside the while loop) until a key is pressed. The benefit of this design is that the wgetch() and wgetstr() functions have a wrefresh() built in so the image refreshes every time a key is pressed which this allows me to highlight/unhighlight text for the user to know where they are since nocecho is called in the noecho() function is called at the initialization of the gameWindow class.
    
Game window
    The gameWindow class is defined in its own file. This class helps with the general input and drawings of the game, the input and drawings that do not depend on the userPlant object to draw anything. I decided to make this a class because this allows me to initialize different requirements and variables that are reused a lot throughout the game like the height and width of the terminal and colors that are going to be used.
    
Crop, Tulip & Eucalyptus
    The Crop class is the parent class and Tulip/Eucalyptus classes inherit from the Crop class. This inheritance is mainly used for the individual requirements of the plants since they do not have the same requirements for water, soil, sunlight, etc. This is handled by a virtual function merRequirements(). Since this is a virtual function the parent class is an abstract class that helps deriving the stats of the plant. Another virtual function in Crop is the getType() function. getType() helps the most for the saving and loading of the game. All the other functions of the child classes are used for mutators for variables.
    
Uses of enumerators
    Enumeration classes are heavily used throughout the main gameLoop. Enumeration was implemented to keep track across different files of what step to take depending on the user input. That way if the user chose 'new game' instead of 'load game' (but part of gameWindow) the state of the game can be determined by main.cpp without needing a separate get/set function and variable in the object gameWindow. This way it is like following a process map.
    
main()
    The main function starts with initializing a gameWindow object and asking the user for input. Once the plantType enumeration class is set to either Tulip or Eucalyptus the main function separates into main if statements. if the plantType is Tulip or if it is Eucalyptus. Inside the if statement the corresponding plant is created as a pointer. Inside each if statement if the gameState is loading the game then the readLoadGame() is called. After this the gameLoop() function is called.
    
Main gameLoop()
    The main game loop runs as long as the gameState is start. The game state will change if the health reaches 0 (you lose is printed out to the terminal) and if it reaches 50> (you win is printed out to the terminal). The first step on the gameLoop() function is to clear the screen and draw everything again, the status bar, the plant (different drawings depending if it is a Tulip or Eucalyptus) & and the actions for the day. Re-drawing the stats is important since the color of the stats changes color depending if the requirements are met or not. After this the nextDay() function of the userPlant is called which changes the variables on the game like decreasing water, increasing/decreasing sunlight, etc.
    
 To complie the game ncurses must be installed, for mac using HomeBrew the comand 'brew install ncurses has to be run' and to actually compile run the command 'g++ -std=c++17 -lncurses main.cpp Crop.cpp Tulip.cpp Eucalyptus.cpp -o main' in the working directory.

